<!-- ---
export_on_save:
 html: true
--- -->

離散化
---

離散化的概念是將**無限空間中的有限個元素**映射到**有限空間**，一般在離散化的狀況中，我們不在乎元素確切的值，只在乎其大小關係或元素出現的數量。

舉例而言，我們可如下將$a$數組離散化成$b$數組。

- 原數組：$a = [-567, 9999, 444, -11111, 444]$
- 離散化：$b = [2, 4, 3, 1, 3]$

不難看出，離散化其實只是按元素大小順序重新編號而已，因此離散化數組具有一些特性。
- 大小關係不變：
  - 原數組中較大者，離散化後仍然較大，反之亦然
- 區間變小：
  - 原數組區間為$[-11111, 9999]$，離散化後區間為$[1, 4]$
  - 離散化後區間不可能大於$[1, n]$，因為即使每個元素都不相同，最多也只有數列長度$n$種元素
- 去除負數

--- 

離散化實現：（讚嘆強大的$STL$）
- 複製一個數組（避免改到原值）
- 新數組排序
- 新數組去除重複的元素
- 重新遍歷一次原數組，二分搜尋找對應下標（下標從$0$開始，要對應正數的話要加$1$）

離散化程式碼：
```cpp
  void discrete(vector<int>& v) {
      vector<int> dis;
      // 將所有元素拷貝到另一個數組中
      for (auto it : v)
          dis.pb(it);
      // 排序
      sort(dis.begin(), dis.end());
      // 刪除重複的元素並調整vector大小
      dis.erase(unique(dis.begin(), dis.end()), dis.end());
      // 用二分搜將原值改為排序後下標 + 1（保證正數）
      for (auto& it : v)
          it = lower_bound(dis.begin(), dis.end(), it) - dis.begin() + 1;
  }
```

---

離散化常用狀況：
- 線段樹或樹狀數組：
  - 有時候數據範圍大（如$[-1e9, 1e9]$），難以作為資料結構的下標使用，但元素數量有限，便可離散化
  - 例子：P1908 逆序對
    > 問題描述：
    > 有一長度為$n$的正整數數列，求逆序對的數量。
    > 一個逆序對的定義是數列中的任兩數$a_i, a_j$，滿足$i < j$且$a_i > a_j$。
    > 
    > 數據範圍：
    > $n \leq 5 \times 10 ^ 5$
    > $a_i \leq 1e9$

  - 說明：
    1. 觀察：假定逆序對左邊的點為$a_i$，則所有數列上在其右側，且小於$a_i$的點都可和它組成一組逆序對，換言之，在$a_i$右側，且屬於$[1, a_i - 1]$區間的元素皆符合條件
    2. 作法：首先建立一棵全為$0$的線段樹，然後由$a_n$倒序遍歷到$a_1$，對於每個元素$a_i$，查詢$[1, a_i - 1]$的數量加入答案，並在線段樹上將$a_i$加$1$，遍歷結束即可求得答案
    3. 解釋：當遍歷到$a_i$時，線段樹$[l, r]$的意義為由$a_{i + 1}$到$a_n$，屬於$[l, r]$的元素的數量
    4. 以上是一個應用線段樹的解法，但你沒有辦法真的開一個$[1, 1e9]$的線段樹（$MLE$警告），因此要先做離散化將範圍縮小
- 並查集：
  - 與線段樹的狀況類似，一樣是數據範圍過大（或是負數）的問題
  - 例子：P1955 程序自動分析